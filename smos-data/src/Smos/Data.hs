{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}

module Smos.Data
  ( module Smos.Data.Types,
    readSmosFile,
    writeSmosFile,
    parseSmosFile,
    parseSmosFileYaml,
    parseSmosFileJSON,
    parseSmosData,
    parseSmosDataYaml,
    parseSmosDataJSON,
    smosFileBS,
    smosFileYamlBS,
    smosFileJSONBS,
    smosFileJSONPrettyBS,
    emptySmosFile,
    makeSmosFile,
    prettySmosForest,
    smosFileClockOutEverywhere,
    entryClockIn,
    entryClockOut,
    logbookClockIn,
    logbookClockOut,
    stateHistoryState,
    stateHistorySetState,
    entryState,
    entrySetState,
  )
where

import Control.Arrow
import Data.Aeson as JSON
import Data.Aeson.Encode.Pretty as JSON
import Data.ByteString (ByteString)
import qualified Data.ByteString as SB
import qualified Data.ByteString.Lazy as LB
import Data.SemVer as Version
import qualified Data.Text as T
import Data.Time
import Data.Tree
import Data.Validity
import Data.Yaml as Yaml
import Data.Yaml.Builder as Yaml
import Lens.Micro
import Path
import Path.IO
import Smos.Data.Types
import UnliftIO.IO.File

readSmosFile :: Path Abs File -> IO (Maybe (Either String SmosFile))
readSmosFile fp = do
  mContents <- forgivingAbsence $ SB.readFile $ toFilePath fp
  case mContents of
    Nothing -> pure Nothing
    Just "" -> pure $ Just $ Right emptySmosFile
    Just contents_ -> pure $ Just $ parseSmosFile contents_

writeSmosFile :: Path Abs File -> SmosFile -> IO ()
writeSmosFile fp sf = do
  ensureDir $ parent fp
  writeBinaryFileDurableAtomic (toFilePath fp) (smosFileBS sf)

parseSmosFile :: ByteString -> Either String SmosFile
parseSmosFile = parseWithVersionCheck parseSmosData

parseSmosFileYaml :: ByteString -> Either String SmosFile
parseSmosFileYaml = parseWithVersionCheck parseSmosDataYaml

parseSmosFileJSON :: ByteString -> Either String SmosFile
parseSmosFileJSON = parseWithVersionCheck parseSmosDataJSON

parseWithVersionCheck :: (forall a. FromJSON a => ByteString -> Either String a) -> ByteString -> Either String SmosFile
parseWithVersionCheck parseFunc sb =
  case parseFunc sb of
    Right sf -> Right sf
    Left _ -> do
      Versioned {..} <- parseFunc sb
      let parsedMajor = versionedVersion ^. Version.major
      let oldestMajor = oldestParsableDataVersion ^. Version.major
      let newestMajor = newestParsableDataVersion ^. Version.major
      if parsedMajor >= oldestMajor
        then
          if parsedMajor <= newestMajor
            then parseEither parseJSON versionedValue
            else
              Left $
                unwords
                  [ "This file was generated by a newer version of smos, upgrade to smos-data version",
                    Version.toString (version parsedMajor 0 0 [] []),
                    "to parse it."
                  ]
        else
          Left $
            unlines
              [ "This file was generated by an older version of smos.",
                "Parsing it is no longer supported.",
                "Downgrade your smos-data version to parse it."
              ]

parseSmosData :: FromJSON a => ByteString -> Either String a
parseSmosData bs =
  let py = parseSmosDataYaml bs
      pj = parseSmosDataJSON bs
   in case (py, pj) of
        (Left pye, Left pje) ->
          Left $ unlines ["Failed to parse smos data as json:", pje, "and also as yaml:", pye]
        (Right pyv, _) -> pure pyv
        (_, Right pjv) -> pure pjv

parseSmosDataYaml :: FromJSON a => ByteString -> Either String a
parseSmosDataYaml = left show . Yaml.decodeEither'

parseSmosDataJSON :: FromJSON a => ByteString -> Either String a
parseSmosDataJSON = JSON.eitherDecode . LB.fromStrict

smosFileBS :: SmosFile -> ByteString
smosFileBS = smosFileYamlBS

smosFileYamlBS :: SmosFile -> ByteString
smosFileYamlBS = Yaml.toByteString

smosFileJSONBS :: SmosFile -> LB.ByteString
smosFileJSONBS = JSON.encode

smosFileJSONPrettyBS :: SmosFile -> LB.ByteString
smosFileJSONPrettyBS = JSON.encodePretty

emptySmosFile :: SmosFile
emptySmosFile = makeSmosFile []

makeSmosFile :: Forest Entry -> SmosFile
makeSmosFile f = SmosFile {smosFileForest = f}

prettySmosForest :: Forest Entry -> String
prettySmosForest ts = unlines $ map prettySmosTree ts

prettySmosTree :: Tree Entry -> String
prettySmosTree Node {..} = unlines [prettySmosEntry rootLabel, prettySmosForest subForest]

prettySmosEntry :: Entry -> String
prettySmosEntry Entry {..} = T.unpack $ headerText entryHeader

smosFileClockOutEverywhere :: UTCTime -> SmosFile -> SmosFile
smosFileClockOutEverywhere now sf = sf {smosFileForest = goF (smosFileForest sf)}
  where
    goT (Node e f_) = Node (entryClockOut now e) (goF f_)
    goF = map goT

entryClockIn :: UTCTime -> Entry -> Entry
entryClockIn now e = maybe e (\lb -> e {entryLogbook = lb}) $ logbookClockIn now (entryLogbook e)

entryClockOut :: UTCTime -> Entry -> Entry
entryClockOut now e = maybe e (\lb -> e {entryLogbook = lb}) $ logbookClockOut now (entryLogbook e)

logbookClockIn :: UTCTime -> Logbook -> Maybe Logbook
logbookClockIn now lb =
  case lb of
    LogClosed es ->
      let d = constructValid $ LogOpen now es
       in case es of
            [] -> d
            (LogbookEntry {..} : rest) ->
              if logbookEntryEnd == now
                then Just $ LogOpen logbookEntryStart rest
                else d
    LogOpen {} -> Nothing

logbookClockOut :: UTCTime -> Logbook -> Maybe Logbook
logbookClockOut now lb =
  case lb of
    LogClosed {} -> Nothing
    LogOpen start es -> constructValid $ LogClosed $ LogbookEntry start now : es

stateHistoryState :: StateHistory -> Maybe TodoState
stateHistoryState (StateHistory tups) =
  case tups of
    [] -> Nothing
    (StateHistoryEntry mts _ : _) -> mts

stateHistorySetState :: UTCTime -> Maybe TodoState -> StateHistory -> Maybe StateHistory
stateHistorySetState now mts sh =
  constructValid $ sh {unStateHistory = StateHistoryEntry mts now : unStateHistory sh}

entryState :: Entry -> Maybe TodoState
entryState = stateHistoryState . entryStateHistory

entrySetState :: UTCTime -> Maybe TodoState -> Entry -> Maybe Entry
entrySetState now mts e = do
  sh' <- stateHistorySetState now mts $ entryStateHistory e
  pure $ e {entryStateHistory = sh'}
